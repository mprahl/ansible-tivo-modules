#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# (c) 2017, Matt Prahl
#
# This module is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this software. If not, see <http://www.gnu.org/licenses/>.

import os
import subprocess as sp
import shutil
import tempfile
import re

from ansible.module_utils.basic import AnsibleModule

ANSIBLE_METADATA = {
    'metadata_version': '1.0',
    'supported_by': 'community',
    'status': ['preview']
}

DOCUMENTATION = '''
---
module: convert_and_cut_recordings
short_description: Cuts commercials and converts video files to MP4
description:
   - Cuts commercials using comskip and converts recordings to compressed MP4s
options:
  source:
    description:
      - The video or folder of mpg videos to convert.
    required: true
  destination:
    description:
      - >
        The destination file path for the output video file or the folder
        to place all output video files to.
    required: false
  replace:
    description:
      - Delete the original files.
    required: false
    default: false
  video_codec:
    description:
      - The ffmpeg video codec to use.
    required: false
    default: libx265
  video_quality:
    description:
      - The ffmpeg crf value.
    required: false
    default: 28
  audio_codec:
    description:
      - The ffmpeg audio codec to use.
    required: false
    default: aac
  audio_quality:
    description:
      - The sample rate in KB used for audio quality.
    required: false
    default: 192
  compression_speed:
    description:
      - The ffmpeg compression speed to use (balance between speed and size).
    required: false
    default: medium
  comskip_path:
    description:
      - The path to the comskip binary.
    required: false
    default: /opt/tivo/comskip
  comskip_ini:
    description:
      - The path to the comskip configuration file to use.
    required: false
  commercial_times:
    description:
      - >
        A list of strings where each string contains a start and end time of a
        commercial in the format of "hh:mm:dd-hh:mm:dd". If this is specified,
        it will be used instead of comskip.
    required: false
'''

EXAMPLES = '''
# Convert and cut commercials on a single video
- convert_recordings:
    source: /home/user/recording.mpg
    comskip_ini: /home/user/comskip.ini

# Convert and cut commercials with manually entered commercial times
- convert_recordings:
    source: /home/user/recording.mpg
    commercial_times:
    - '00:00:00-00:01:23'
    - '00:09:50-00:12:30'
    - '00:20:18-00:21:25'

# Convert a single video with libx264 (H.264) and remove the source without
# cutting commercials
- convert_recordings:
    source: /home/user/recording.mpg
    video_codec: libx264
    video_quality: 23
    replace: true

# Convert and cut commercials on multiple mpg videos
- convert_recordings:
    source: /home/user/recordings/
    comskip_ini: /home/user/comskip.ini
'''

# Make the module global
module = None


def cleanup(temp_dir):
    """
    Cleans up a temporary directory
    :param temp_dir: a string of the directory to delete.
    :return: None
    """
    try:
        shutil.rmtree(temp_dir)
    except Exception:
        msg = 'An error occurred when cleaning up "{0}"'.format(temp_dir)
        module.fail(msg=msg, changed=True)


def comskip(source, output_dir, comskip_path, ini):
    """
    Uses comskip to cut the commercials
    :param source: a string of the source video file.
    :param output_dir: a string of the directory to put the comskip files
    :param comskip_path: a string to the path of the comskip binary.
    :param ini: a string to the path of the comskip configuration file to use.
    :return: a string to the path of edl file generated by comskip.
    """
    cmd = [comskip_path, '--output', output_dir, '--ini', ini, source]
    comskip_proc = sp.Popen(cmd, stdout=sp.PIPE, stderr=sp.PIPE)
    stdout, stderr = comskip_proc.communicate()
    if comskip_proc.returncode != 0:
        cleanup(output_dir)
        msg = ('Comskip failed. The following was called "{0}" and the '
               'error was "{1}"'.format(' '.join(cmd), stderr))
        module.fail_json(msg=msg)

    edl_file = os.path.basename(os.path.splitext(source)[0]) + '.edl'
    edl_file = os.path.join(output_dir, edl_file)
    if not os.path.exists(edl_file):
        cleanup(output_dir)
        msg = ('Comskip didn\'t create an edl file. The following was called '
               '"{0}"'.format(' '.join(cmd)))
        module.fail_json(msg=msg)
    return edl_file


def get_segments(edl_file=None, commercial_times=None, padding=0.0):
    """
    Gets the segments to keep in the video file based on the values in the edl
    file or the list of commercial times.
    :param edl_file: a string of the path to the edl file that comskip
    generated. This is required if "commercial_times" is not provided.
    :param commercial_times: a list of lists where each nested list contains a
    start and end time to drop in the format of hh:mm:dd. This is required if
    "edl_file" isn't provided.
    :param padding: a float specifying how much to pad the segments in
    seconds. This defaults to 0.0.
    :return: a list of tuples with a start and finish time in seconds of the
    video content to keep.
    """
    if not edl_file and not commercial_times:
        msg = ('The "get_segments" function requires the "edl_file" or '
               '"commercial_times" parameter. Neither were provided.')
        module.fail_json(msg=msg)
    padding = float(padding)
    segments = []
    prev_segment_end = 0.0
    if edl_file:
        with open(edl_file, 'rb') as edl:
            # EDL contains segments to drop, so chain those together into
            # segments to keep
            for segment in edl:
                start, end, _ = segment.split()
                start = float(start)
                end = float(end)
                if start != 0.0:
                    segments.append((prev_segment_end, start + padding))
                prev_segment_end = end
    else:
        for segment in commercial_times:
            start = float(
                (int(segment[0].split(':')[0]) * 60 * 60) +
                (int(segment[0].split(':')[1]) * 60) +
                int(segment[0].split(':')[2]))
            end = float(
                (int(segment[1].split(':')[0]) * 60 * 60) +
                (int(segment[1].split(':')[1]) * 60) +
                int(segment[1].split(':')[2]))
            if start != 0.0:
                segments.append((prev_segment_end, start + padding))
            prev_segment_end = end

    # Write the final keep segment from the end of the last commercial break to
    # the end of the file
    keep_segment = (prev_segment_end, -1)
    segments.append(keep_segment)
    return segments


def get_trim_filter(segments):
    """
    Get the ffmpeg trim filter for removing the commercial segments
    :return: a string of the ffmpeg trim filter to cut the video
    """
    trim = ''
    trim_end = {'v': '', 'a': ''}
    count = 0
    for stream in ['v', 'a']:
        for segment in segments:
            prefix = ''
            if stream == 'a':
                prefix = 'a'
            # If the segment is "-1", then it means it goes to the end of the
            # video, so there shouldn't be an end specified in the filter
            if segment[1] == -1:
                end_text = ''
            else:
                end_text = ':end={0}'.format(segment[1])
            trim += ('[0:{stream}]{prefix}trim=start={start}{end},'
                     '{prefix}setpts=PTS-STARTPTS[{count}];'.format(
                         stream=stream, start=segment[0], end=end_text,
                         prefix=prefix, count=count))
            trim_end[stream] += '[{count}]'.format(count=count)
            count += 1
    trim_end_str = '{prefix}concat=n={total}[outv]; '.format(
        prefix=trim_end['v'], total=int(count/2))
    trim_end_str += '{prefix}concat=v=0:a=1:n={total}[outa]'.format(
        prefix=trim_end['a'], total=int(count/2))
    trim += trim_end_str
    return trim


def video_to_mp4(temp_dir, source, destination=None, video_quality=28,
                 video_codec='libx265', audio_codec='aac', audio_quality=192,
                 compression_speed='medium', comskip_path='/opt/tivo/comskip',
                 comskip_ini=None, commercial_times=None):
    """
    Converts a video file to MP4 using ffmpeg.
    :param source: a string of the source file
    :param destination: a string of the destination file. This defaults to the
    same location and name but with the ".mp4" file extension.
    :param video_quality: an integer of the ffmpeg crf value for video quality.
    This defaults to `28`.
    :param video_codec: a string of the ffmpeg video codec to use. This
    defaults to `libx265`.
    :param audio_quality: an int of the sample rate in KB used for audio
    quality. This defaults to `192`.
    :param audio_codec: a string of the ffmpeg audio codec to use. This
    defaults to `aac`.
    :param compression_speed: a string of the ffmpeg compression speed to use.
    This defaults to `medium`.
    :param comskip_path: a string of the path to the comskip binary.
    :param comskip_ini: a string of the path to the comskip ini file to use
    when cutting commercials. If this is not set, then commericial skipping
    will be skipped.
    :param commercial_times: a list of lists where each nested list contains a
    start and end time to drop in the format of hh:mm:dd.
    :return: a string of the path to the converted video file.
    """
    if destination:
        destination_path = destination
    else:
        destination_path = source.rsplit('.', 1)[0] + '.mp4'

    command = ['ffmpeg', '-y', '-loglevel', 'error', '-hide_banner', '-i',
               source, '-c:v', video_codec, '-preset', compression_speed,
               '-crf', str(video_quality), '-c:a', str(audio_codec), '-b:a',
               '{0}K'.format(audio_quality)]

    # If comskip_ini is specified, then cut the commercials
    if commercial_times or comskip_ini:
        # If both are provided, prefer the list of commercial times
        if not commercial_times:
            edl_file = comskip(source, temp_dir, comskip_path, comskip_ini)
            segments = get_segments(edl_file=edl_file)
        else:
            segments = get_segments(commercial_times=commercial_times)
        trim_filter = get_trim_filter(segments)
        command += ['-filter_complex', trim_filter, '-map', '[outv]', '-map',
                    '[outa]']
    command.append(destination_path)
    convert_proc = sp.Popen(command, stdout=sp.PIPE, stderr=sp.PIPE)
    stdout, stderr = convert_proc.communicate()
    if convert_proc.returncode != 0:
        msg = ('The conversion failed. The following was called "{0}" and the '
               'error was "{1}"'.format(' '.join(command), stderr))
        module.fail_json(msg=msg)

    return destination_path


def main():
    """
    The main function where the module starts
    :return: None
    """
    global module
    module = AnsibleModule(
        argument_spec={
            'source': {'required': True, 'type': 'str'},
            'destination': {'required': False, 'type': 'str'},
            'replace': {'default': False, 'type': 'bool'},
            'video_quality': {'default': 28, 'type': 'int'},
            'video_codec': {'default': 'libx265', 'type': 'str'},
            'audio_codec': {'default': 'aac', 'type': 'str'},
            'audio_quality': {'default': 192, 'type': 'int'},
            'compression_speed': {'default': 'medium', 'type': 'str'},
            'comskip_path': {'default': '/opt/tivo/comskip',
                             'type': 'str'},
            'comskip_ini': {'required': False, 'type': 'str'},
            'commercial_times': {'required': False, 'type': 'list'}
        },
        supports_check_mode=False
    )
    source = module.params['source']
    destination = module.params.get('destination')
    replace = module.params['replace']
    video_quality = module.params['video_quality']
    video_codec = module.params['video_codec']
    audio_codec = module.params['audio_codec']
    audio_quality = module.params['audio_quality']
    compression_speed = module.params['compression_speed']
    comskip_path = module.params['comskip_path']
    comskip_ini = module.params['comskip_ini']

    commercial_times = []
    if module.params['commercial_times']:
        for times in module.params['commercial_times']:
            msg = ('The parameter "commercial_times" must be a list of '
                   'strings, with each sting containing a start and end time '
                   'in the format of "hh:mm:ss-hh:mm:ss"')
            time_regex = r'^\d\d:\d\d:\d\d-\d\d:\d\d:\d\d$'
            if type(times) != str or not re.match(time_regex, times):
                module.fail_json(msg=msg)
            else:
                commercial_times.append(times.split('-'))

    compression_speeds = ['ultrafast', 'superfast', 'veryfast', 'faster',
                          'fast', 'medium', 'slow', 'slower', 'veryslow']
    if compression_speed not in compression_speeds:
        compression_speeds_str = ', '.join(compression_speeds)
        msg = ('The selected compression speed of "{0}" is invalid. Select '
               'from: {1}'.format(compression_speed, compression_speeds_str))
        module.fail_json(msg=msg)

    if not os.path.exists(source):
        module.fail_json(msg='The source does not exist')

    source_is_dir = os.path.isdir(source)
    if destination:
        dest_exists = os.path.exists(destination)
        dest_is_dir = os.path.isdir(destination)
        if dest_exists and dest_is_dir != source_is_dir:
            msg = 'The source and destination need to be the same type'
            module.fail_json(msg=msg)

    videos_to_convert = []
    if source_is_dir:
        for item in os.listdir(source):
            full_path = os.path.join(source, item)
            if item.lower().endswith('.mpg') and os.path.isfile(full_path):
                videos_to_convert.append(full_path)
    else:
        videos_to_convert.append(os.path.abspath(source))

    temp_dir = tempfile.mkdtemp()
    for video in videos_to_convert:
        video_to_mp4(temp_dir, video, destination, video_quality=video_quality,
                     video_codec=video_codec, audio_codec=audio_codec,
                     audio_quality=audio_quality,
                     compression_speed=compression_speed,
                     comskip_path=comskip_path, comskip_ini=comskip_ini,
                     commercial_times=commercial_times)
        if replace:
            os.remove(video)
    # Clean up the temp dir that was created for comskip files
    cleanup(temp_dir)

    if len(videos_to_convert) > 0:
        success_msg = '{0} recording(s) converted successfully'.format(
            len(videos_to_convert))
        module.exit_json(msg=success_msg, changed=True)
    else:
        msg = 'No recordings were found that matched the criteria'
        module.exit_json(msg=msg, changed=False)


if __name__ == '__main__':
    main()
